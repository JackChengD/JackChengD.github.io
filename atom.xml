<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>学习之路</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://jackchengd.github.io/"/>
  <updated>2020-05-10T12:44:17.319Z</updated>
  <id>https://jackchengd.github.io/</id>
  
  <author>
    <name>JackCheng</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>前端性能优化</title>
    <link href="https://jackchengd.github.io/2020/05/10/fe-optimization/"/>
    <id>https://jackchengd.github.io/2020/05/10/fe-optimization/</id>
    <published>2020-05-10T12:30:31.000Z</published>
    <updated>2020-05-10T12:44:17.319Z</updated>
    
    <content type="html"><![CDATA[<p>文章是为一些关于前端性能优化的方案，会不定期的更新，希望能给读者一点帮助。</p><a id="more"></a><h2 id="性能优化的方法"><a href="#性能优化的方法" class="headerlink" title="性能优化的方法"></a>性能优化的方法</h2><h3 id="防抖（debounce）与节流（throttle）"><a href="#防抖（debounce）与节流（throttle）" class="headerlink" title="防抖（debounce）与节流（throttle）"></a>防抖（debounce）与节流（throttle）</h3><h4 id="防抖"><a href="#防抖" class="headerlink" title="防抖"></a>防抖</h4><blockquote><p>原理解释：<br>防抖就是将几次操作合并为一次操作，原理是维护一个计时器，规定在deley时间后触发函数，但是在delay时间内再次触发的话，就会取消之前的计时器而重新设置，这样一来，只有最后一次函数才会被执行。抖完了再执行，读进度条  </p></blockquote><blockquote><p>使用场景：<br>用户在输入框不断输入，只有最后一次输入才会被执行(百度搜索框)   </p></blockquote><blockquote><p>代码实现：  </p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//防抖</span></span><br><span class="line"><span class="keyword">const</span> debounce = <span class="function">(<span class="params">fn,delay</span>)=&gt;</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> timer = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(timer!==<span class="literal">null</span>)&#123;</span><br><span class="line">      clearTimeout(timer);</span><br><span class="line">    &#125;</span><br><span class="line">    timer = setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">      fn.apply(<span class="keyword">this</span>)</span><br><span class="line">    &#125;,delay)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> a = debounce(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">11</span>)</span><br><span class="line">&#125;,<span class="number">1000</span>)</span><br></pre></td></tr></table></figure><h4 id="节流"><a href="#节流" class="headerlink" title="节流"></a>节流</h4><blockquote><p>原理解释：<br>节流就是使得一定时间内只触发一次函数，原理是通过判断是否达到一定时间来触发    </p></blockquote><blockquote><p>节流的原因：<br>为了限制函数的执行频率，用于优化函数触发频率过高而导致响应速度跟不上触发频率而出现bug、延迟、卡顿等现象<br>比如window对象的resize、scroll事件、拖拽时的mousemove事件、射击游戏中的mousedown、keydown事件</p></blockquote><blockquote><p>使用场景：<br>在页面的无限加载场景下，比如我们需要用户在滚动时，每隔一段时间内触发一次ajax请求，而不是在用户停下滚动页面操作时才会去请求。这样的场景适合节流技术来实现    </p></blockquote><blockquote><p>代码实现：  </p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//节流</span></span><br><span class="line"><span class="keyword">const</span> throttle = <span class="function">(<span class="params">fn, delay = <span class="number">500</span></span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> flag = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!flag) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    flag = <span class="literal">false</span>;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      fn.apply(<span class="keyword">this</span>);</span><br><span class="line">      flag = <span class="literal">true</span>;</span><br><span class="line">    &#125;, delay)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> a = throttle(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">11</span>)</span><br><span class="line">&#125;, <span class="number">1000</span>)</span><br><span class="line">a()</span><br></pre></td></tr></table></figure><blockquote><p>小编的个人博客中是否显示<strong>返回自顶组件</strong>采用了节流，可以试试。链接为：<a href="http://ldc.hzuser.cn:83/my-blog/#/" target="_blank" rel="noopener">http://ldc.hzuser.cn:83/my-blog/#/</a>   </p></blockquote><h3 id="懒加载"><a href="#懒加载" class="headerlink" title="懒加载"></a>懒加载</h3><h4 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h4><blockquote><p>对于图片过多的使用场景，为了提高页面加载速度，改善用户体验，我们对未出现在视野范围的图片先不加载，等到出现视野范围采取加载</p></blockquote><h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><blockquote><p>使用懒加载做能防止一次性向服务器相应大量请求导致服务器响应慢，页面卡顿或崩溃等问题，提高网站的性能  </p></blockquote><h4 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h4><p>1.先img标签中的src链接设为同一张图片（空白图片），将其真正的图片地址存储在img标签的自定义属性中（比如data-img）<br>2.当js监听到该图片元素进入可视窗口时，即将自定义属性中的地址存储到src属性中，达到懒加载的效果  </p><h3 id="前端文件设置为gzip"><a href="#前端文件设置为gzip" class="headerlink" title="前端文件设置为gzip"></a>前端文件设置为gzip</h3><h4 id="使用webpack配置gzip压缩文件"><a href="#使用webpack配置gzip压缩文件" class="headerlink" title="使用webpack配置gzip压缩文件"></a>使用webpack配置gzip压缩文件</h4><p>1.压缩插件<strong>compression-webpack-plugin</strong>，该插件可以将大文件压缩成gzip的格式，操作非常的简单   </p><p>2.引入插件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev compression-webpack-plugin</span><br></pre></td></tr></table></figure><blockquote><p>如果运行时发现报错，可能是版本问题，这是时候可以将版本降为<strong>1.1.12</strong>  </p></blockquote><p>3.添加webpack配置</p><blockquote><p>因为是打包时才需要用到，所以可以在webpack.build.config.js下修改。如果webpack在同一文件，这时可以区别环境来配置   </p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> CompressionWebpackPlugin = <span class="built_in">require</span>(<span class="string">"compression-webpack-plugin"</span>);</span><br><span class="line"><span class="comment">// 这里我只压缩js、css文件</span></span><br><span class="line"><span class="keyword">const</span> productionGzipExtensions = [<span class="string">"js"</span>, <span class="string">"css"</span>];</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 在插件下添加以下代码：</span></span><br><span class="line">   <span class="comment">// 文件压缩为gzip</span></span><br><span class="line">   plugins: [</span><br><span class="line">      <span class="keyword">new</span> CompressionWebpackPlugin(&#123;</span><br><span class="line">         algorithm: <span class="string">"gzip"</span>,</span><br><span class="line">         test: <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">`\\.(<span class="subst">$&#123;productionGzipExtensions.join(<span class="string">"|"</span>)&#125;</span>)$`</span>),</span><br><span class="line">         threshold: <span class="number">10240</span>, <span class="comment">//对超过10k的数据进行压缩</span></span><br><span class="line">         minRatio: <span class="number">0.6</span> <span class="comment">// 压缩比例，值为0 ~ 1</span></span><br><span class="line">      &#125;)</span><br><span class="line">   ]</span><br></pre></td></tr></table></figure><p>4.启动项目打包   </p><blockquote><p>打包成功后，会发现多了.gzip后缀的文件    </p></blockquote><h4 id="nginx作为服务器，开启gzip"><a href="#nginx作为服务器，开启gzip" class="headerlink" title="nginx作为服务器，开启gzip"></a>nginx作为服务器，开启gzip</h4><p>1.修改nginx.conf文件的配置  </p><blockquote><p>添加下面代码   </p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">  # 开启gzip on为开启，off为关闭</span><br><span class="line">  gzip on;</span><br><span class="line">  # 检查是否存在请求静态文件的gz结尾的文件，如果有则直接返回该gz文件内容，不存在则先压缩再返回</span><br><span class="line">  gzip_static on;</span><br><span class="line">  # 设置允许压缩的页面最小字节数，页面字节数从header头中的Content-Length中进行获取。</span><br><span class="line">  # 默认值是0，不管页面多大都压缩。</span><br><span class="line">  # 建议设置成大于10k的字节数，配合compression-webpack-plugin</span><br><span class="line">  gzip_min_length 10k;</span><br><span class="line">  # 获取多少内存用于缓存压缩结果，‘16  8k’表示以8k*16 为单位获得。</span><br><span class="line">  # PS: 如果没有.gz文件，是需要Nginx实时压缩的</span><br><span class="line">  gzip_buffers 16 8k;</span><br><span class="line">  # 注：99.99%的浏览器基本上都支持gzip解压了，所以可以不用设这个值,保持系统默认即可。</span><br><span class="line">  gzip_http_version 1.1; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.配置成功后重启即可  </p><p>3.参考</p><blockquote><p>该优化方案主要参考掘金： <a href="https://juejin.im/post/5eb2243e51882555d8457833" target="_blank" rel="noopener">https://juejin.im/post/5eb2243e51882555d8457833</a>   </p></blockquote><h3 id="CDN引入"><a href="#CDN引入" class="headerlink" title="CDN引入"></a>CDN引入</h3><blockquote><p>CDN（内容分发网络）的主要工作是把我们需要被分发的内容发到世界各地的各个节点上，让世界各地的人都可以在距离最近，压力最小的网络节点拿到想要拿到的内容，减少网络传输距离从而达到加速的目的（需要提供资源绝对地址告诉CDN厂商，让厂商去智能拉取）<br>CDN能够缓存一般的CSS、js、图片等静态资源文件，而这些文件的访问频率很高，将其缓存在CDN可以极大的提高网站的访问速度<br>当CDN服务器中缓存有用户请求的数据时，就可以从CDN直接返回给客户端浏览器，最短路径的返回响应，加快用户的访问速度，减少数据中心的负载压力  </p></blockquote><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote><p>多实战<br>多遇问题<br>然后解决问题<br>再做个记录  </p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;文章是为一些关于前端性能优化的方案，会不定期的更新，希望能给读者一点帮助。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="性能优化" scheme="https://jackchengd.github.io/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>webpack配置--解决vue-router按需引入路径出错问题</title>
    <link href="https://jackchengd.github.io/2020/05/09/webpack-vue-router/"/>
    <id>https://jackchengd.github.io/2020/05/09/webpack-vue-router/</id>
    <published>2020-05-09T12:05:01.000Z</published>
    <updated>2020-05-09T12:02:53.982Z</updated>
    
    <content type="html"><![CDATA[<p>使用nginx部署vue多页项目后，发现vue-router按需引入路径出错，在当前路径下找不到？</p><a id="more"></a><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><blockquote><p>本人使用nginx部署多页项目，即使dist里面有多文件（一个文件相当于一个页面），nginx.conf可以配置如下  </p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">location &#x2F; &#123;</span><br><span class="line">      root &#x2F;root&#x2F;personweb&#x2F;dist;</span><br><span class="line">      index index.html index.htm;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>如果没有采用vue-router按需引入，不会报错。<br>而采用按需引入，则一般的结果是你会发现线上的地址居然出错了？  </p></blockquote><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><blockquote><p>修改webpack.build.config.js的如下配置就可以  </p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">output: &#123;</span><br><span class="line">  chunkFilename: &#39;index&#x2F;[name].[chunkhash:8].js&#39;,</span><br><span class="line">  path: path.resolve(__dirname, &#39;..&#x2F;dist&#39;),</span><br><span class="line">  filename: &#96;[name].[chunkhash:8].js&#96;,</span><br><span class="line">  publicPath: &#39;&#x2F;&#39;&#x2F;&#x2F;如果打包后出现引入报错问题，一般都是这个</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><blockquote><p>当你没有配置<strong>publicPath: ‘/‘</strong>时，线上链接会从你页面下的路径去找按需引入的路由，可是路由被打包到根目录dist的index文件下，所以会出现找不到的情况。这时候将查找的路径改为从根路径开始即可。  </p></blockquote><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote><p>哈哈哈哈，其实也没啥好总结的就是改改webpack里面的配置就好，看看报错的原因进行分析。  </p></blockquote><h2 id="题外话"><a href="#题外话" class="headerlink" title="题外话"></a>题外话</h2><blockquote><p>最近准备考研<br>目前只把高数、线代基础学了，刷着汤老师的1800题<br>现在的学习计划是：白天考研学习、晚上前端学习<br>毕业后去北京学点东西、长点见识<br>考个北京学校的在研   </p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;使用nginx部署vue多页项目后，发现vue-router按需引入路径出错，在当前路径下找不到？&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="nginx" scheme="https://jackchengd.github.io/tags/nginx/"/>
    
  </entry>
  
  <entry>
    <title>Linux的基本命令</title>
    <link href="https://jackchengd.github.io/2020/04/02/linux-command/"/>
    <id>https://jackchengd.github.io/2020/04/02/linux-command/</id>
    <published>2020-04-02T14:11:31.000Z</published>
    <updated>2020-04-02T15:56:39.197Z</updated>
    
    <content type="html"><![CDATA[<p>Linux是最知名和最常用的开源操作系统。作为一个操作系统，Linux是一个软件，位于计算机上的所有其他软件的下面，从这些程序接收请求并将这些请求转发到计算机硬件</p><a id="more"></a><p>我们使用术语“Linux”来指代Linux内核，也是通常与Linux内核捆绑在一起的程序，工具和服务，以提供所有必需的组件全功能操 作系统。有些人，特别是自由软件基金会的成员，将此集合称为GNU / Linux，因为包括的许多工具都是GNU组件。但是并不是所有的Linux安装都使用GNU组件作为其操作系统的一部分。例如，Android使用 Linux内核，但对GNU工具依赖性很低。这个介绍文章部分参考于《linux就该这么学》，希望对于大家的理解有帮助</p><p>那么我们就知道了，通常我们说的“linux”其实是指linux内核，而linux操作系统其实是GNU/linux（GNU/linux是指 ，linux内核+GNU组织的软件）</p><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><p>1.date——显示日期  </p><blockquote><p>date</p></blockquote><p>2.cal——显示日历  </p><blockquote><p>cal</p></blockquote><p>3.uname——查看系统  </p><blockquote><p>uname</p></blockquote><p>4.uname -r——查看版本  </p><blockquote><p>uname -r  </p></blockquote><p>5.cd——更换目录  </p><blockquote><p>切换到根目录：cd /<br>切换到上一级目录：cd ..<br>切换到当前用户家目录： cd  </p></blockquote><p>6.pwd——显示当前所在目录  </p><blockquote><p>pwd  </p></blockquote><p>7.mkdir——建立新目录  </p><blockquote><p>普通用法：mkdir abc<br>建多层次目录： mkdir -p a/b/c<br>mkdir  x/a x/b x/c</p></blockquote><p>8.rmdir——删除空的目录  </p><blockquote><p>rmdir a</p></blockquote><p>9.rm -rf——删除文件、目录  </p><blockquote><p>rm -rf -a</p></blockquote><p>10.ls——显示文件、目录  </p><blockquote><p>查看隐藏文件：ls -a   </p></blockquote><p>11.cp——复制文件或目录  </p><blockquote><p>拷贝文件：cp a.md b.md<br>拷贝文件夹 cp -r a a-temp</p></blockquote><p>12.rm—–移除文件或目录  </p><blockquote><p>rm install.log 普通删除文件<br>rm -f install.log 强制删除文件<br>rm -r -f abc 删除文件夹<br>rm -rf a 删除文件夹 -r和-f两个短参数可以合到一起  </p></blockquote><p>13.cat—–显示全部文档内容 </p><blockquote><p>cat nginx.conf</p></blockquote><p>14.less——分屏显示，按b查看下一屏</p><blockquote><p>less nginx.conf</p></blockquote><p>15.head——显示前十行  </p><blockquote><p>head nginx.conf</p></blockquote><p>16.tail——显示后十行   </p><blockquote><p>tail nginx.conf</p></blockquote><p>17.whereis——寻找特定文件</p><blockquote><p>whereis nginx.conf     </p></blockquote><p>18.find——寻找特定文件 </p><blockquote><p>find / -name ‘nginx.conf’</p></blockquote><p>19.stat——显示文件的元数据   </p><blockquote><p>stat a.md</p></blockquote><p>20.vi——编辑器  </p><blockquote><p>vi nginx.conf</p></blockquote><p>21.clear——清屏  </p><blockquote><p>clear   </p></blockquote><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote><p>作为一个入门运维的小前端，简单的梳理并掌握这些linux命令应该就差不多了吧，其他比较不常用的可以再谷歌或百度一波</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Linux是最知名和最常用的开源操作系统。作为一个操作系统，Linux是一个软件，位于计算机上的所有其他软件的下面，从这些程序接收请求并将这些请求转发到计算机硬件&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>jenkins使用pm2部署express项目</title>
    <link href="https://jackchengd.github.io/2020/03/28/jenkins-pm2/"/>
    <id>https://jackchengd.github.io/2020/03/28/jenkins-pm2/</id>
    <published>2020-03-28T06:00:31.000Z</published>
    <updated>2020-04-02T15:56:03.371Z</updated>
    
    <content type="html"><![CDATA[<p>承接我上一篇文章(jenkins部署vue项目)，使用pm2部署，其实也就是改个shell命令再安装下pm2</p><a id="more"></a><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>承接我上一篇文章(jenkins部署vue项目)，使用pm2部署，其实也就是改个shell命令再安装下pm2</p><h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><h3 id="安装pm2"><a href="#安装pm2" class="headerlink" title="安装pm2"></a>安装pm2</h3><blockquote><p>首先服务器需要安装pm2   </p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install pm2 -g</span><br></pre></td></tr></table></figure><h3 id="构建express"><a href="#构建express" class="headerlink" title="构建express"></a>构建express</h3><blockquote><p>构建和上一篇文章是一样的，只需要修改shell命令即可，可使用以下命令</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">echo &#39;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;check ENV&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#39; </span><br><span class="line">whoami</span><br><span class="line">which npm</span><br><span class="line">#npm install -g cnpm --registry&#x3D;https:&#x2F;&#x2F;registry.npm.taobao.org</span><br><span class="line">node -v</span><br><span class="line">npm -v</span><br><span class="line">cnpm -v</span><br><span class="line"></span><br><span class="line">echo &#39;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;begin build&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#39;</span><br><span class="line">cd $WORKSPACE</span><br><span class="line">#执行命令安装</span><br><span class="line">cnpm install</span><br><span class="line">pm2 start bin&#x2F;www</span><br><span class="line">echo &#39;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;end build&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#39;</span><br></pre></td></tr></table></figure><blockquote><p>这时候基本上就差不多了，你可以看到pm2已经守护了进程www，浏览器也可以访问该url</p></blockquote><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote><p>jenkins环境搭建成功后，后面部署就是一件简单的事情了，只需要构建修改下shell命令就差不多了<br>环境的搭建才是比较累人的，后面就自动化部署就非常香了，代码提交到github上，点一下部署就行，很香</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;承接我上一篇文章(jenkins部署vue项目)，使用pm2部署，其实也就是改个shell命令再安装下pm2&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>jenkins部署vue项目</title>
    <link href="https://jackchengd.github.io/2020/03/27/jenkins-vue/"/>
    <id>https://jackchengd.github.io/2020/03/27/jenkins-vue/</id>
    <published>2020-03-27T14:32:31.000Z</published>
    <updated>2020-04-02T15:56:22.468Z</updated>
    
    <content type="html"><![CDATA[<p>最近把个人网站和博客都搭建的差不多，也成功放到nginx服务器，接下来要折腾的就是想弄个自动化部署jenkins，这个操作还是有点点累的，查阅了部分文章，终于成功了。这篇文章，我感觉别人写的比我好，这里我就引入别人的文章最为参考吧</p><a id="more"></a><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>最近把个人网站和博客都搭建的差不多，也成功放到nginx服务器，接下来要折腾的就是想弄个自动化部署jenkins，这个操作还是有点点累的，查阅了部分文章，终于成功了。这篇文章，我感觉别人写的比我好，这里我就引入别人(大佬)的文章最为参考吧</p><h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><h3 id="git搭建"><a href="#git搭建" class="headerlink" title="git搭建"></a>git搭建</h3><blockquote><p>git的搭建可以参考下面这边文章，并且他也做了后面jenkins可能引入git报错的处理<br>git安装完后，记得将公钥绑定到自己的github上<br><strong>git安装文章</strong>：<a href="https://blog.csdn.net/legend818/article/details/104148913" target="_blank" rel="noopener">https://blog.csdn.net/legend818/article/details/104148913</a><br><strong>查看公钥文章</strong>：<a href="https://blog.csdn.net/suwyer/article/details/86066929" target="_blank" rel="noopener">https://blog.csdn.net/suwyer/article/details/86066929</a>   </p></blockquote><h3 id="centOS安装jenkins"><a href="#centOS安装jenkins" class="headerlink" title="centOS安装jenkins"></a>centOS安装jenkins</h3><blockquote><p>可以参考下面这边文章，只是安装的时候有点慢，我当时都等了半天，成功进入后还需要安装插件<br><strong>jenkins安装地址</strong>：<a href="https://www.cnblogs.com/loveyouyou616/p/8714544.html" target="_blank" rel="noopener">https://www.cnblogs.com/loveyouyou616/p/8714544.html</a><br><strong>插件安装文章</strong>：<a href="https://blog.csdn.net/ziwuzhulin/article/details/79820020" target="_blank" rel="noopener">https://blog.csdn.net/ziwuzhulin/article/details/79820020</a>    </p></blockquote><h3 id="部署vue项目"><a href="#部署vue项目" class="headerlink" title="部署vue项目"></a>部署vue项目</h3><blockquote><p>部署vue简单讲其实就是npm install、npm build的过程，参考下面这边文章，文章看到构建那里就差不多了，下面可以不需要<br>需要注意的是 <code>cd /var/jenkins_home/workspace/test #进入test项目目录</code>，这里的/var/jenkins_home/workspace/test是jenkins的工作区目录，也就是在jenkins将代码拉到这，如果你使用nginx反代，那么目录需要改成这个，或者你可以在构建的时候把dist文件拷贝到另外一个文件(nginx反代这文件)。这样避免build的时候把dist文件删除了，导致线上出现404<br>还有一点构建时的源码管理Credentials的用户、密码可以是你登录jenkins的账号密码<br><strong>部署vue文章</strong>：<a href="https://blog.csdn.net/ansu2009/article/details/83584796" target="_blank" rel="noopener">https://blog.csdn.net/ansu2009/article/details/83584796</a>   </p></blockquote><h3 id="个人建议"><a href="#个人建议" class="headerlink" title="个人建议"></a>个人建议</h3><blockquote><p>vue部署的shell命令，可以采用下面这个<br>注意：<br>1.使用cnpm install来安装依赖可以避免一些问题，比如sass<br>2.可以给jenkins开权限<br><strong>开权限参考</strong>：<a href="https://blog.csdn.net/liuxiaoming1109/article/details/89099317" target="_blank" rel="noopener">https://blog.csdn.net/liuxiaoming1109/article/details/89099317</a>  </p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">echo &#39;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;check ENV&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#39; </span><br><span class="line">whoami</span><br><span class="line">which npm</span><br><span class="line">#npm install -g cnpm --registry&#x3D;https:&#x2F;&#x2F;registry.npm.taobao.org</span><br><span class="line">node -v</span><br><span class="line">npm -v</span><br><span class="line">cnpm -v</span><br><span class="line"></span><br><span class="line">echo &#39;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;begin build&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#39;</span><br><span class="line">rm -rf $WORKSPACE&#x2F;dist&#x2F;</span><br><span class="line">mkdir -p $WORKSPACE&#x2F;dist&#x2F;</span><br><span class="line">cd $WORKSPACE</span><br><span class="line">#执行命令安装</span><br><span class="line">cnpm install</span><br><span class="line">npm run build</span><br><span class="line">echo &#39;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;end build&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#39;</span><br><span class="line">echo &#39;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;start copy&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#39;</span><br><span class="line"></span><br><span class="line">\cp -rf $WORKSPACE&#x2F;dist&#x2F; b</span><br><span class="line">#b为你个人的项目目录</span><br><span class="line">echo &#39;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;end copy&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#39;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote><p>jenkins部署vue还是繁琐一点的，步骤如下   </p></blockquote><ol><li>先安装git环境，将git绑定到线上github   </li><li>服务器安装jenkins环境，浏览器安装jenkins插件解决问题   </li><li>将git绑定到jenkins上   </li><li>初始化jenkins项目   </li><li>构建，看控制台输出是否成功   </li></ol><blockquote><p>jenkins部署vue大致过程如上，如有问题还可以继续百度<br>以上过程应该可以避免90%以上的问题，哈哈哈哈哈哈~   </p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近把个人网站和博客都搭建的差不多，也成功放到nginx服务器，接下来要折腾的就是想弄个自动化部署jenkins，这个操作还是有点点累的，查阅了部分文章，终于成功了。这篇文章，我感觉别人写的比我好，这里我就引入别人的文章最为参考吧&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>前端如何正常显示.md</title>
    <link href="https://jackchengd.github.io/2020/03/23/md-html/"/>
    <id>https://jackchengd.github.io/2020/03/23/md-html/</id>
    <published>2020-03-23T08:30:31.000Z</published>
    <updated>2020-04-02T15:56:51.618Z</updated>
    
    <content type="html"><![CDATA[<p>最近在搭建自己的博客时，想着如何在html显示.md的文件使文章可以直接用.md的格式来写，这样方便很多</p><a id="more"></a><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>最近在搭建自己的博客时，想着如何在html显示.md的文件使文章就可以直接用.md的格式来写，这样方便很多</p><h2 id="引入将-md转成html的库"><a href="#引入将-md转成html的库" class="headerlink" title="引入将.md转成html的库"></a>引入将.md转成html的库</h2><h3 id="markedjs"><a href="#markedjs" class="headerlink" title="markedjs"></a>markedjs</h3><blockquote><p>引入marked开始转html<br>具体详情可以看官网：<a href="https://github.com/markedjs/marked" target="_blank" rel="noopener">https://github.com/markedjs/marked</a><br>直接cdn引入:   </p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.jsdelivr.net/npm/marked/marked.min.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>安装npm引入</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install markedjs --save</span><br></pre></td></tr></table></figure><blockquote><p>使用</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> marked = <span class="built_in">require</span>(<span class="string">"marked"</span>);</span><br><span class="line">marked.setOptions(&#123;</span><br><span class="line">   renderer: <span class="keyword">new</span> marked.Renderer(),</span><br><span class="line">   gfm: <span class="literal">true</span>,</span><br><span class="line">   tables: <span class="literal">true</span>,</span><br><span class="line">   breaks: <span class="literal">false</span>,</span><br><span class="line">   pedantic: <span class="literal">false</span>,</span><br><span class="line">   sanitize: <span class="literal">false</span>,</span><br><span class="line">   smartLists: <span class="literal">true</span>,</span><br><span class="line">   smartypants: <span class="literal">false</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"> <span class="built_in">document</span>.getElementById(<span class="string">'content'</span>).innerHTML = marked(<span class="string">'# Marked in the browser\n\nRendered by **marked**.'</span>);</span><br></pre></td></tr></table></figure><blockquote><p>这时候就可以在html上正常看到.md转成html，可是它却没有.md的样式，这是需要我们自己引入的   </p></blockquote><h3 id="如果使用webpack打包的项目"><a href="#如果使用webpack打包的项目" class="headerlink" title="如果使用webpack打包的项目"></a>如果使用webpack打包的项目</h3><blockquote><p>需要让js认识.md文件<br>先引入html-loader、markdown-loader   </p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install html-loader、markdown-loader --save</span><br></pre></td></tr></table></figure><blockquote><p>修改webpack配置，在rules添加以下代码，否则编译通不过</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#123; </span><br><span class="line">   test: <span class="regexp">/\.md$/</span>,</span><br><span class="line">   use: [ </span><br><span class="line">      &#123; <span class="attr">loader</span>: <span class="string">'html-loader'</span> &#125;,</span><br><span class="line">      &#123; <span class="attr">loader</span>: <span class="string">'markdown-loader'</span>, <span class="attr">options</span>: &#123;&#125;&#125; </span><br><span class="line">   ]</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">   test: <span class="regexp">/\.js$/</span>,</span><br><span class="line">   include: [<span class="regexp">/marked/</span>],</span><br><span class="line">   use: [</span><br><span class="line">      <span class="string">'babel-loader'</span>,</span><br><span class="line">   ]   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="引入-md的样式"><a href="#引入-md的样式" class="headerlink" title="引入.md的样式"></a>引入.md的样式</h2><blockquote><p>这里采用github-markdown-css，当然你也可以选择你自己喜欢的<br>github: <a href="https://github.com/sindresorhus/" target="_blank" rel="noopener">https://github.com/sindresorhus/</a>   github-markdown-css<br>安装npm引入</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install github-markdown-css --save</span><br></pre></td></tr></table></figure><blockquote><p>使用</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'github-markdown-css'</span>;</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"markdown-body"</span> <span class="attr">id</span>=<span class="string">"content"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote><p>只需要将.md转成html再引相应的样式，最后显示即可</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近在搭建自己的博客时，想着如何在html显示.md的文件使文章可以直接用.md的格式来写，这样方便很多&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="markdown" scheme="https://jackchengd.github.io/tags/markdown/"/>
    
  </entry>
  
  <entry>
    <title>使用pm2守护解决nuxt部署、express部署</title>
    <link href="https://jackchengd.github.io/2020/03/17/pm2-deplay/"/>
    <id>https://jackchengd.github.io/2020/03/17/pm2-deplay/</id>
    <published>2020-03-17T07:09:07.000Z</published>
    <updated>2020-04-02T15:57:25.594Z</updated>
    
    <content type="html"><![CDATA[<p>上一篇文章，nuxt部署感觉出现了问题，发现我的部署只是表明部署，不是真正的部署，为了解决这个问题写了这文章</p><a id="more"></a><!-- more --><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>上一篇文章，nuxt部署感觉出现了问题，发现我的部署只是表明部署，不是真正的部署，为了解决这个问题写了这文章</p><h2 id="pm2"><a href="#pm2" class="headerlink" title="pm2"></a>pm2</h2><h3 id="安装pm2"><a href="#安装pm2" class="headerlink" title="安装pm2"></a>安装pm2</h3><blockquote><p>前面我们已经安装过node、nginx，在这我就不说了，可以看看我的上一篇文章<br>全局安装pm2  </p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cnpm install -g pm2</span><br></pre></td></tr></table></figure><blockquote><p>pm2的一些命令详情<br>pm2 ls # 查看当前守护情况<br>pm2 start all  # 启动所有应用<br>pm2 restart all  # 重启所有应用<br>pm2 stop all # 停止所有的应用程序<br>pm2 delete all # 关闭并删除所有应用<br>pm2 logs # 控制台显示所有日志<br>pm2 start 0  # 启动 id为 0的指定应用程序<br>pm2 restart 0  # 重启 id为 0的指定应用程序<br>pm2 stop 0 # 停止 id为 0的指定应用程序<br>pm2 delete 0 # 删除 id为 0的指定应用程序<br>pm2 logs 0 # 控制台显示编号为0的日志<br>pm2 show 0  # 查看执行编号为0的进程<br>pm2 monit jsyfShopNuxt # 监控名称为jsyfShopNuxt的进程  </p></blockquote><h2 id="nuxt部署"><a href="#nuxt部署" class="headerlink" title="nuxt部署"></a>nuxt部署</h2><blockquote><p>只需要把项目放入远程服务器(阿里云、腾讯云)你的指定位置，文件（除node_modules）不需要放入<br>进入到你的指定位置<br>npm install 安装依赖<br>pm2 start npm –name “nuxt” – run dev<br>通过pm2 ls就可以看到pm2守护情况，这时候浏览器就可以访问了<br>注意：服务器需要开启对应的端口、run dev是你项目的运行命令  </p></blockquote><h2 id="express部署"><a href="#express部署" class="headerlink" title="express部署"></a>express部署</h2><blockquote><p>只需要把项目放入远程服务器(阿里云、腾讯云)你的指定位置，文件（除node_modules）不需要放入<br>进入到你的指定位置<br>npm install 安装依赖<br>pm2 start bin/www即可<br>通过pm2 ls就可以看到pm2守护情况，这时候浏览器就可以访问了<br>注意：服务器需要开启对应的端口、bin/www是你的运行文件  </p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上一篇文章，nuxt部署感觉出现了问题，发现我的部署只是表明部署，不是真正的部署，为了解决这个问题写了这文章&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>如何使用CentOS7.3从0开始安装nginx并部署vue、nuxt项目</title>
    <link href="https://jackchengd.github.io/2020/03/02/nginx-install/"/>
    <id>https://jackchengd.github.io/2020/03/02/nginx-install/</id>
    <published>2020-03-02T14:09:07.000Z</published>
    <updated>2020-04-02T15:57:12.487Z</updated>
    
    <content type="html"><![CDATA[<p>前两天买了个阿里云的服务器，所以尝试了一手，如何安装使用nginx，在这分享给大家</p><a id="more"></a><!-- more --><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>前两天买了个阿里云的服务器，所以尝试了一手，如何安装使用nginx，在这分享给大家</p><h2 id="nginx"><a href="#nginx" class="headerlink" title="nginx"></a>nginx</h2><h3 id="安装nginx"><a href="#安装nginx" class="headerlink" title="安装nginx"></a>安装nginx</h3><ol><li><p>安装gcc gcc-c++(如新环境,未安装请先安装)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ yum install -y gcc gcc-c++</span><br></pre></td></tr></table></figure></li><li><p>安装nginx</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1. $ cd &#x2F;usr&#x2F;local&#x2F;</span><br><span class="line">2. $ wget http:&#x2F;&#x2F;nginx.org&#x2F;download&#x2F;nginx-1.8.0.tar.gz</span><br><span class="line">3. $ tar -zxvf nginx-1.8.0.tar.gz</span><br><span class="line">4. $ cd nginx-1.8.0</span><br><span class="line">5. $ .&#x2F;configure --user&#x3D;nobody --group&#x3D;nobody --prefix&#x3D;&#x2F;usr&#x2F;local&#x2F;nginx --with-http_stub_status_module --with-http_gzip_static_module --with-http_realip_module --with-http_sub_module --with-http_ssl_module</span><br><span class="line">6. $ make &amp;&amp; make install</span><br></pre></td></tr></table></figure></li><li><p>启动命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">启动：$ &#x2F;usr&#x2F;local&#x2F;nginx&#x2F;sbin&#x2F;nginx</span><br><span class="line">重新加载：$ &#x2F;usr&#x2F;local&#x2F;nginx&#x2F;sbin&#x2F;nginx –s reload</span><br><span class="line">停止：$ &#x2F;usr&#x2F;local&#x2F;nginx&#x2F;sbin&#x2F;nginx –s stop</span><br><span class="line">测试配置文件是否正常：$ &#x2F;usr&#x2F;local&#x2F;nginx&#x2F;sbin&#x2F;nginx –t</span><br><span class="line">强制关闭：$ pkill nginx</span><br></pre></td></tr></table></figure></li><li><p>是否成功</p><blockquote><p>通过个人服务器ip查看，默认端口80</p></blockquote></li></ol><h3 id="修改nginx启动命令"><a href="#修改nginx启动命令" class="headerlink" title="修改nginx启动命令"></a>修改nginx启动命令</h3><ol><li>修改以下配置<blockquote><p>在 <strong>/etc/init.d/</strong>下创建名为nginx的启动脚本即可，内容如下：</p></blockquote></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;bash</span><br><span class="line">#</span><br><span class="line"># chkconfig: - 85 15</span><br><span class="line"># description: Nginx is a World Wide Web server.</span><br><span class="line"># processname: nginx</span><br><span class="line"></span><br><span class="line">nginx&#x3D;&#x2F;usr&#x2F;local&#x2F;nginx&#x2F;sbin&#x2F;nginx</span><br><span class="line">conf&#x3D;&#x2F;usr&#x2F;local&#x2F;nginx&#x2F;conf&#x2F;nginx.conf</span><br><span class="line">case $1 in</span><br><span class="line">start)</span><br><span class="line">echo -n &quot;Starting Nginx&quot;</span><br><span class="line">$nginx -c $conf</span><br><span class="line">echo &quot; done&quot;</span><br><span class="line">;;</span><br><span class="line">stop)</span><br><span class="line">echo -n &quot;Stopping Nginx&quot;</span><br><span class="line">killall -9 nginx</span><br><span class="line">echo &quot; done&quot;</span><br><span class="line">;;</span><br><span class="line">test)</span><br><span class="line">$nginx -t -c $conf</span><br><span class="line">;;</span><br><span class="line">reload)</span><br><span class="line">echo -n &quot;Reloading Nginx&quot;</span><br><span class="line">ps auxww | grep nginx | grep master | awk &#39;&#123;print $2&#125;&#39; | xargs kill -HUP</span><br><span class="line">echo &quot; done&quot;</span><br><span class="line">;;</span><br><span class="line">restart)</span><br><span class="line">$0 stop</span><br><span class="line">$0 start</span><br><span class="line">;;</span><br><span class="line">show)</span><br><span class="line">ps -aux|grep nginx</span><br><span class="line">;;</span><br><span class="line">*)</span><br><span class="line">echo -n &quot;Usage: $0 &#123;start|restart|reload|stop|test|show&#125;&quot;</span><br><span class="line">;;</span><br><span class="line">esac</span><br></pre></td></tr></table></figure><blockquote><p>设置执行权限：chmod +x /etc/init.d/nginx<br>注册成服务：chkconfig -add nginx<br>设置开机启动：chkconfig nginx on   </p></blockquote><ol start="2"><li>修改后<blockquote><p>之后，就可以使用以下命令了<br>启动：service nginx start<br>停止：service nginx stop<br>重新加载：service nginx resload<br>service nginx reload   </p></blockquote></li></ol><h2 id="nginx部署vue项目"><a href="#nginx部署vue项目" class="headerlink" title="nginx部署vue项目"></a>nginx部署vue项目</h2><ol><li><p>vue打包</p><blockquote><p>个人通过npm run build生成dist文件  </p></blockquote></li><li><p>将文件传到centOS系统，远程服务器可以通过Xshell、Xftp</p></li><li><p>开始部署</p><blockquote><p>进入 /usr/local/nginx/conf<br>开启vi编辑器 vi nginx.conf<br>添加以下内容  </p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">server &#123; </span><br><span class="line">    listen  Vue项目的端口号;</span><br><span class="line">    server_name  localhost;</span><br><span class="line">    #charset koi8-r;</span><br><span class="line">    #access_log  logs&#x2F;host.access.log  main;</span><br><span class="line">    location &#x2F; &#123;</span><br><span class="line">     root vue的dist文件夹的路径，比如：&#x2F;root&#x2F;guobao&#x2F;dist;</span><br><span class="line">     index index.html index.html;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>补充，开启多端口</p><blockquote><p>除了添加server，配端口以外，还需要，比如：个人阿里云上开启端口，否则也是访问不了新添加的server</p></blockquote></li><li><p>重新加载</p><blockquote><p>每次修改nginx.conf文件后，都要重新加载   </p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ service nginx reload</span><br></pre></td></tr></table></figure></li></ol><h2 id="nginx部署nuxt项目"><a href="#nginx部署nuxt项目" class="headerlink" title="nginx部署nuxt项目"></a>nginx部署nuxt项目</h2><h3 id="安装node环境"><a href="#安装node环境" class="headerlink" title="安装node环境"></a>安装node环境</h3><ol><li><p>安装wget</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ yum install wget -y</span><br></pre></td></tr></table></figure></li><li><p>安装node</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">1. 下载： $ wget https:&#x2F;&#x2F;nodejs.org&#x2F;dist&#x2F;v10.13.0&#x2F;node-v10.13.0-linux-x64.tar.xz</span><br><span class="line">2. 解压： $ xz -d node-v10.13.0-linux-x64.tar.xz</span><br><span class="line">3 .解压： $ tar xvf node-v10.13.0-linux-x64.tar</span><br><span class="line">4. 安装nodejs</span><br><span class="line">   1. cd node-v10.13.0-linux-x64</span><br><span class="line">　　　　2. cd bin</span><br><span class="line">　　　　3. mv .&#x2F;node &#x2F;bin&#x2F;</span><br><span class="line">　　　　4. mv .&#x2F;npm &#x2F;bin&#x2F;</span><br><span class="line">　　　　5. mv .&#x2F;npx &#x2F;bin&#x2F;</span><br><span class="line">　　　　6. cd .. cd lib</span><br><span class="line">　　　　7. mv .&#x2F;node_modules &#x2F;lib&#x2F;</span><br><span class="line">5. 安装nrm：$ npm install nrm -g</span><br><span class="line">6. 安装pm2：$ npm install pm2 -g</span><br><span class="line">7. 查看版本：$ node --version</span><br></pre></td></tr></table></figure></li><li><p>开始部署</p><blockquote><ol><li>拷贝文件<br>拷贝文件（.nuxt、static、nuxt.config.js、package.json）至服务器部署目录（比如：/root/nuxt）  </li><li>测试<br>cd /root/nuxt<br>npm install -production<br>npm run start<br>发现可以运行   </li><li>nginx配置<br>进入 /usr/local/nginx/conf<br>开启vi编辑器 vi nginx.conf<br>添加以下内容   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">server &#123; </span><br><span class="line">    listen  Nuxt项目的端口号;</span><br><span class="line">    server_name  localhost;</span><br><span class="line">    #charset koi8-r;</span><br><span class="line">    #access_log  logs&#x2F;host.access.log  main;</span><br><span class="line">    location &#x2F; &#123;</span><br><span class="line">     root vue的dist文件夹的路径，比如：&#x2F;root&#x2F;nuxt;</span><br><span class="line">     # 需要做反向代理</span><br><span class="line">     proxy_pass http:&#x2F;&#x2F;127.0.0.1:3000; </span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>重新加载<br>每次修改nginx.conf文件后，都要重新加载   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ service nginx reload</span><br></pre></td></tr></table></figure></li></ol></blockquote></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前两天买了个阿里云的服务器，所以尝试了一手，如何安装使用nginx，在这分享给大家&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>hexo搭建github博客，只要这几步就够</title>
    <link href="https://jackchengd.github.io/2020/03/02/hexostyle/"/>
    <id>https://jackchengd.github.io/2020/03/02/hexostyle/</id>
    <published>2020-03-02T12:51:36.058Z</published>
    <updated>2020-03-02T12:51:36.058Z</updated>
    
    <content type="html"><![CDATA[<p>如果你想搭建一个很不错的博客，那么hexo将会是你不错的选择，你可以通过这篇文章利用hexo快速简洁高效的优势帮助你搭建个人博客</p><a id="more"></a><h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><h3 id="git安装"><a href="#git安装" class="headerlink" title="git安装"></a>git安装</h3><p>找到<a href="https://git-scm.com/download/win" target="_blank" rel="noopener">Git</a>进行傻瓜式安装<br>通过cmd查看是否安装成功 git –version，若打印出版本即安装完毕</p><h3 id="node安装"><a href="#node安装" class="headerlink" title="node安装"></a>node安装</h3><p>找到<a href="http://nodejs.cn/" target="_blank" rel="noopener">Node</a>进行傻瓜式安装<br>通过cmd查看是否安装成功 node –version，npm –version。若打印出版本即安装完毕</p><h3 id="hexo-cli安装"><a href="#hexo-cli安装" class="headerlink" title="hexo-cli安装"></a>hexo-cli安装</h3><p>通过npm install hexo-cli -g，对hexo-cli进行全局安装</p><h3 id="初始化项目"><a href="#初始化项目" class="headerlink" title="初始化项目"></a>初始化项目</h3><p>hexo init blog：初始化项目，耐心等待<br>cd blog：进入blog文件<br>npm install：安装依赖</p><h4 id="文件介绍"><a href="#文件介绍" class="headerlink" title="文件介绍"></a>文件介绍</h4><p>node_modules：依赖包<br>public：存放生成的页面<br>scaffolds：生成文章的一些模板<br>source：用来存放你的文章<br>themes：主题<br>_config.yml：博客的配置文件</p><h4 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h4><p>hexo clean：清除你之前生成的东西，也可以不加<br>hexo generate：生成静态文章，可以用hexo g缩写<br>hexo server 启动hexo，可以在浏览器localhost:4000查看你的博客，可以用hexo s缩写</p><h2 id="部署到个人GitHub"><a href="#部署到个人GitHub" class="headerlink" title="部署到个人GitHub"></a>部署到个人GitHub</h2><h3 id="github创建个人仓库"><a href="#github创建个人仓库" class="headerlink" title="github创建个人仓库"></a>github创建个人仓库</h3><p>在这里默认你已经有自己的github并且密钥都配置好了<br>这时你可以在Github.com中点击New repository新建仓库，创建一个和你用户名相同的仓库，后面加.github.io，只有这样，将来要部署到GitHub page的时候，才会被识别，也就是xxxx.github.io，其中xxx就是你注册GitHub的用户名</p><h3 id="hexo配置"><a href="#hexo配置" class="headerlink" title="hexo配置"></a>hexo配置</h3><p>现在需要我们将hexo和github关联起来。在你初始化的hexo文件找到_config.yml，翻到最后做如下配置<br>将repository中的JackChengD修改为个人的GitHub账户名</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">    <span class="attr">repository:</span> <span class="string">git@github.com:JackChengD/JackChengD.github.io.git</span></span><br><span class="line">    <span class="attr">branch:</span> <span class="string">master</span></span><br></pre></td></tr></table></figure><h3 id="最后一步"><a href="#最后一步" class="headerlink" title="最后一步"></a>最后一步</h3><p>这时候，你已经基本完成hexo个人博客的搭建，只需要将以下命令操作一下就可以成功了<br>hexo clean—清除你之前生成的东西，也可以不加<br>hexo generate—生成静态文章，可以用hexo g缩写<br>hexo deploy—部署文章，可以用hexo d缩写<br>操作完毕后，你就可以访问到自己的github博客，地址栏输入jackchengd.github.io。将jackchengd改为你个人GitHub账户就可以访问啦</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>利用hexo搭建个人博客是不是非常的简洁快速，你还可以选择个人主题对你的博客做更多美化哟，但接下来的操作需要你个人手动去实现哦，博主就不多说啦，加油，学习之路永不停止</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;如果你想搭建一个很不错的博客，那么hexo将会是你不错的选择，你可以通过这篇文章利用hexo快速简洁高效的优势帮助你搭建个人博客&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>如何将dom转换图片-网页截图</title>
    <link href="https://jackchengd.github.io/2019/10/28/htmlToBase/"/>
    <id>https://jackchengd.github.io/2019/10/28/htmlToBase/</id>
    <published>2019-10-28T09:09:07.000Z</published>
    <updated>2020-03-02T13:01:19.976Z</updated>
    
    <content type="html"><![CDATA[<p>今天公司遇到了一个业务，需要将dom转为图片然后分享出去。这时我们可以使用html2canvas或者domtoimage将dom转换为图片，在这分享给大家如何使用</p><a id="more"></a><h2 id="如何转换"><a href="#如何转换" class="headerlink" title="如何转换"></a>如何转换</h2><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>今天公司遇到了一个业务，需要将dom转为图片然后分享出去。这时我们可以使用html2canvas或者domtoimage将dom转换为图片，在这分享给大家如何使用</p><h3 id="两个区别"><a href="#两个区别" class="headerlink" title="两个区别"></a>两个区别</h3><ol><li>domtoimage与html2canvas都是功能差不多的第三方js插件，能够把dom节点转换为矢量图（svg）和位图（png和jpeg），完美解决了html2canvas出现过的坑</li><li>Android下（dom-to-image），IPhone（html2canvas)</li><li>html2canvas文档：<a href="http://html2canvas.hertzen.com/" target="_blank" rel="noopener">http://html2canvas.hertzen.com/</a></li><li>domtoimage转换出来的图片会比html2canvas的要小且模糊一点</li></ol><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><h3 id="html2canvas使用"><a href="#html2canvas使用" class="headerlink" title="html2canvas使用"></a>html2canvas使用</h3><p>1.引入第三方库：npm install html2canvas –save<br>如果你是nuxt项目，那么还需要做以下配置</p><ol><li>找到/plugins文件，在文件中新建html2canvas.js配置如下代码<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span>;</span><br><span class="line"><span class="keyword">import</span> html2canvas <span class="keyword">from</span> <span class="string">'html2canvas'</span>;</span><br><span class="line"></span><br><span class="line">Vue.prototype.$html2canvas = html2canvas;</span><br></pre></td></tr></table></figure></li><li>找到/nuxt.config.js，在添加如下代码<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">plugins: [</span><br><span class="line">  &#123;</span><br><span class="line">    src: <span class="string">'@/plugins/html2canvas'</span>, <span class="attr">ssr</span>: <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">],</span><br></pre></td></tr></table></figure></li><li>nuxt具体使用<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> dom = <span class="keyword">this</span>.refs.dom;</span><br><span class="line"><span class="keyword">this</span>.$html2canvas(dom).then(<span class="function"><span class="params">canvas</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(canvas.toDataURL(<span class="string">"image/jpeg"</span>));<span class="comment">//canvas为格式为base64的图片</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ol><p>3.正常具体使用</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> dom = <span class="keyword">this</span>.refs.dom;</span><br><span class="line">html2canvas(dom).then(<span class="function"><span class="params">canvas</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(canvas.toDataURL(<span class="string">"image/jpeg"</span>));<span class="comment">//canvas为格式为base64的图片</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="domtoimage使用"><a href="#domtoimage使用" class="headerlink" title="domtoimage使用"></a>domtoimage使用</h3><p>1.引入第三方库：npm install domtoimage –save<br>2.具体使用</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> dom = <span class="keyword">this</span>.refs.dom;</span><br><span class="line">domtoimage.toPng(dom).then(<span class="function"><span class="params">imageBase</span>=&gt;</span>&#123;<span class="comment">//转为Png</span></span><br><span class="line">    <span class="built_in">console</span>.log(imageBase);<span class="comment">//base64的图片</span></span><br><span class="line">&#125;)</span><br><span class="line">domtoimage.toJpeg(dom).then(<span class="function"><span class="params">imageBase</span>=&gt;</span>&#123;<span class="comment">//转为Jpeg</span></span><br><span class="line">    <span class="built_in">console</span>.log(imageBase);<span class="comment">//base64的图片</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><ol><li>dom不存在或者隐藏，即使是opacity:0都不可以，也不要试图通过克隆一份dom再将这份dom转为图片</li><li>图片会被压缩</li><li>如果你的图片不想被压缩的太严重，你可以不要将这个图片作为背景引入，采用img标签引入</li><li>html2canvas在手机测试转换的过程会比较慢，domtoimage比较快。线上基本一样</li><li>html2canvas可以做一些配置，大家可以自行查阅文档信息</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天公司遇到了一个业务，需要将dom转为图片然后分享出去。这时我们可以使用html2canvas或者domtoimage将dom转换为图片，在这分享给大家如何使用&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Git的常用指令，一看就懂</title>
    <link href="https://jackchengd.github.io/2019/10/26/gitstyle/"/>
    <id>https://jackchengd.github.io/2019/10/26/gitstyle/</id>
    <published>2019-10-26T02:11:31.000Z</published>
    <updated>2020-03-23T08:27:59.905Z</updated>
    
    <content type="html"><![CDATA[<p>git是目前世界上最先进的<strong>分布式</strong>版本控制工具，可以有效、高速地处理从很小到非常大的项目版本管理，是 Linus Torvalds 为了帮助管理 Linux 内核开发而开发的一个开放源码的版本控制软件。</p><a id="more"></a><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><blockquote><ul><li>git init：初始化(新建一个文件夹)，将其目录切换至目录上，执行此命令，即可初始化该目录为git</li><li>git status : 查看仓库的状态</li><li>git add filename 将filename添加到git的暂存区</li><li>git commit -m ‘message’ 提交，提交的信息为message</li><li>git commit –amend 修改已提交的commit注释，在vi编辑器改</li><li>git log : 查看所有产生的 commit 记录</li><li>git log filename 查看filename日志</li></ul></blockquote><h3 id="分支相关命令"><a href="#分支相关命令" class="headerlink" title="分支相关命令"></a>分支相关命令</h3><blockquote><ul><li>git branch: 查看所有分支。</li><li>git branch filename: 创建filename分支。</li><li>git checkout filename: 切换到filename的分支上</li><li>git checkout -b filename: 创建filename分支并切换到这个分支上，效果相当于合并上面 2 个命令</li><li>git merge filename: 将filename分支合并到当前分支上</li><li>git rm -f filename 删除filename分支</li><li>git branch -D filename： 删除filename分支</li><li>git branch -D filename： 强制删除filename分支</li><li>git clone -r -d origin/dev<br> git push origin :dev    删除远程分支</li><li>git checkout -b develop origin/develop 本地拉取显示的develop分支代码</li></ul></blockquote><h3 id="标签相关的命令"><a href="#标签相关的命令" class="headerlink" title="标签相关的命令"></a>标签相关的命令</h3><blockquote><ul><li>git tag : 查看历史 tag 记录。</li><li>git tag <tag_name> <commit_id> : 在指定提交 id 上创建一个 tag。如果不写 <commit_id> ，那就在最新的 commit 上创建一个 tag。</li><li>git checkout <tag_name> : 切换到 <tag_name> 标签</li><li>git show <tag_name> : 查看标签信息</li><li>git tad -d <tag_name> : 删除标签</li><li>git push origin <tag_name> : 将某个标签推送到远程仓库</li><li>git push origin :refs/tags/<tag_name> : 可以删除一个远程标签。</li></ul></blockquote><h3 id="github操作"><a href="#github操作" class="headerlink" title="github操作"></a>github操作</h3><blockquote><ul><li>git clone … : 将 github 项目复制到本地的当前目录</li><li>git push origin &lt;本地分支&gt;:&lt;远程分支&gt; : 把本地分支中本地代码同步到远程分支</li><li>git pull orgin <branch_name> : 把远程 <branch_name> 分支的最新的代码同步到本地当前分支中</li><li>get remote add origin <a href="mailto:git@github.com">git@github.com</a>:xxx/xxxx.git : 将当前本地仓库与远程进行联接</li><li>git remote -v : 查看我们当前项目有哪些远程仓库</li></ul></blockquote><h3 id="版本操作"><a href="#版本操作" class="headerlink" title="版本操作"></a>版本操作</h3><blockquote><ul><li>git diff 查看对比两次文件内容具体修改了什么</li><li>git diff HEAD – <code>&lt;filename&gt;</code> (“–”前后有空格，可以查看工作区和版本库里面最新版本的区别)</li><li>git reset –hard HEAD^ 回退一步</li><li>git reset –hard HEAD^^^ 回退三步</li><li>git reflog 查看操作</li><li>git reflog filename 查看详细的操作</li><li>git reset –hard 43ea01 将版本回退到43ea01时的版本</li><li>git reset –hard HEAD~3 回退三步</li><li>git checkout – 版本回撤</li></ul></blockquote><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote><ul><li>git命令需要多动手敲敲，常用的命令就几条</li><li>如果你忘记了，欢迎来到我的博客回顾回顾~</li><li>感觉您的来访，文章如有出错，欢迎指出</li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;git是目前世界上最先进的&lt;strong&gt;分布式&lt;/strong&gt;版本控制工具，可以有效、高速地处理从很小到非常大的项目版本管理，是 Linus Torvalds 为了帮助管理 Linux 内核开发而开发的一个开放源码的版本控制软件。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="git" scheme="https://jackchengd.github.io/tags/git/"/>
    
  </entry>
  
</feed>
